<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PdmContext.ContextClustering API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PdmContext.ContextClustering</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PdmContext.utils.structure import Context
from PdmContext.utils import distances
from matplotlib import pyplot as plt


class DBscanContextStream():


    def __init__(self,cluster_similarity_limit=0.7,min_points=2,distancefunc=None):
        &#34;&#34;&#34;
        A simple clustering method for context (inspired from streaming DBSCAN)

        Parameters:

        cluster_similarity_limit: The similarity upon two clusters are merged

        min_points:

        distancefunc: The function to use in order to calculate two Contexts&#39; similarity. None value results in
        the usage of default distance function implemented in the class.
        In case of user&#39;s distance function, this has to take the two contexts as parameter and

        return a real number in [0,1] indicating their similarity (1 is maximum similarity)
        &#34;&#34;&#34;

        self.cluster_similarity_limit=cluster_similarity_limit
        self.contexts={}
        self.min_points=min_points
        self.index= {}
        self.label= {}
        self.a=0.5
        self.b=1-self.a
        self.clusters_sets=[]
        self.count=-1
        self.D=[]
        self.Co=[] # coexist

        if distancefunc is None:
            self.distanceTouse=self.distance_default
        else:
            self.distanceTouse = distancefunc

    def clusterIsSimilar(self,cluster,id):
        for j in cluster:
            if self.distance(id, j) &gt; self.cluster_similarity_limit:
                return True
        return False

    def distance(self,id1,id2):
        return self.distanceTouse(self.contexts[id1],self.contexts[id2])

    def distance_default(self,c1,c2):
        return distances.distance_cc(c1, c2, self.a, self.b)[0]

    def add_sample_to_cluster(self, context : Context):

        self.count+=1
        self.index[context.timestamp]=self.count
        self.contexts[self.count] = context
        #self.D.append([ self.context_ob.distance_cc(context,self.contexts[i])[0] for i in range(self.count)])
        #self.Co.append([ 1 if self.context_ob.distance_cc(context,self.contexts[i])[0]&gt;self.cluster_similarity_limit else 0 for i in range(self.count)])
        if len(self.clusters_sets)==0:
            self.clusters_sets.append([self.count])
        else:
            similarclusters=[]
            for i,clust in enumerate(self.clusters_sets):
                belong=self.clusterIsSimilar(clust,self.count)
                if belong:
                    similarclusters.append(i)
            if len(similarclusters)==0:
                self.clusters_sets.append([self.count])
            elif len(similarclusters)==1:
                self.clusters_sets[similarclusters[0]].append(self.count)
            else:
                new_clusters=[]
                merge_cluster=[]
                for i,clust in enumerate(self.clusters_sets):
                    if i in similarclusters:
                        merge_cluster.extend(clust)
                    else:
                        new_clusters.append(clust)
                new_clusters.append(merge_cluster)
                self.clusters_sets=new_clusters


    # check if timestamp_target has in its neighborhood one of timestamps_query
    def efficient_neighbor(self,timestamp_target,timestamps_query):
        # get the cluster of target:
        idtarget=self.index[timestamp_target]
        cluserid=-1
        for i in range(len(self.clusters_sets)):
            if idtarget in self.clusters_sets[i]:
                cluserid=i
                break
        if cluserid==-1:
            return False,0
        all_query=timestamps_query.copy()
        in_same_cluster=[]
        for id in self.clusters_sets[cluserid]:
            if self.contexts[id].timestamp in all_query:
                in_same_cluster.append(id)
                all_query.remove(self.contexts[id].timestamp)

        if len(in_same_cluster)==0:
            return False,0

        for id in in_same_cluster:
            dist=self.distance(id,idtarget)
            if dist&gt;self.cluster_similarity_limit:
                return True,dist
        return False,0
    def plot(self):
        num=1
        noisyclust=[]
        for clust in self.clusters_sets:
            if len(clust)&lt;=self.min_points:
                noisyclust.extend(clust)
                continue
            self.plotsingleclust(num,clust)
            num+=1

        self.plotsingleclust(num, noisyclust,&#34;noise&#34;)
        plt.show()


    def plotsingleclust(self,num,clust,desc=None):
        xaxistimes = [self.contexts[id].timestamp for id in clust]
        yaxistimes = [num for id in clust]
        if len(xaxistimes)==0:
            return
        edges = [self.contexts[id].CR[&#34;edges&#34;] for id in clust]
        if len(edges)!=0:
            edgeplot = edges[len(edges) // 2]
        else:
            edgeplot=[]
        toplot = &#34;&#34;
        seen = []
        for ed in edgeplot:
            if (ed[0], ed[1]) not in seen:
                toplot += f&#34;({ed[0]},{ed[1]}),&#34;
                seen.append((ed[1], ed[0]))
                seen.append((ed[0], ed[1]))
        if desc is None:
            plt.text(xaxistimes[len(xaxistimes) // 2], yaxistimes[len(yaxistimes) // 2] + 0.1, toplot, fontsize=8)
        else:
            plt.text(xaxistimes[len(xaxistimes) // 2], yaxistimes[len(yaxistimes) // 2] + 0.1, desc, fontsize=8)

        plt.scatter(xaxistimes, yaxistimes)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PdmContext.ContextClustering.DBscanContextStream"><code class="flex name class">
<span>class <span class="ident">DBscanContextStream</span></span>
<span>(</span><span>cluster_similarity_limit=0.7, min_points=2, distancefunc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple clustering method for context (inspired from streaming DBSCAN)</p>
<p>Parameters:</p>
<p>cluster_similarity_limit: The similarity upon two clusters are merged</p>
<p>min_points:</p>
<p>distancefunc: The function to use in order to calculate two Contexts' similarity. None value results in
the usage of default distance function implemented in the class.
In case of user's distance function, this has to take the two contexts as parameter and</p>
<p>return a real number in [0,1] indicating their similarity (1 is maximum similarity)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DBscanContextStream():


    def __init__(self,cluster_similarity_limit=0.7,min_points=2,distancefunc=None):
        &#34;&#34;&#34;
        A simple clustering method for context (inspired from streaming DBSCAN)

        Parameters:

        cluster_similarity_limit: The similarity upon two clusters are merged

        min_points:

        distancefunc: The function to use in order to calculate two Contexts&#39; similarity. None value results in
        the usage of default distance function implemented in the class.
        In case of user&#39;s distance function, this has to take the two contexts as parameter and

        return a real number in [0,1] indicating their similarity (1 is maximum similarity)
        &#34;&#34;&#34;

        self.cluster_similarity_limit=cluster_similarity_limit
        self.contexts={}
        self.min_points=min_points
        self.index= {}
        self.label= {}
        self.a=0.5
        self.b=1-self.a
        self.clusters_sets=[]
        self.count=-1
        self.D=[]
        self.Co=[] # coexist

        if distancefunc is None:
            self.distanceTouse=self.distance_default
        else:
            self.distanceTouse = distancefunc

    def clusterIsSimilar(self,cluster,id):
        for j in cluster:
            if self.distance(id, j) &gt; self.cluster_similarity_limit:
                return True
        return False

    def distance(self,id1,id2):
        return self.distanceTouse(self.contexts[id1],self.contexts[id2])

    def distance_default(self,c1,c2):
        return distances.distance_cc(c1, c2, self.a, self.b)[0]

    def add_sample_to_cluster(self, context : Context):

        self.count+=1
        self.index[context.timestamp]=self.count
        self.contexts[self.count] = context
        #self.D.append([ self.context_ob.distance_cc(context,self.contexts[i])[0] for i in range(self.count)])
        #self.Co.append([ 1 if self.context_ob.distance_cc(context,self.contexts[i])[0]&gt;self.cluster_similarity_limit else 0 for i in range(self.count)])
        if len(self.clusters_sets)==0:
            self.clusters_sets.append([self.count])
        else:
            similarclusters=[]
            for i,clust in enumerate(self.clusters_sets):
                belong=self.clusterIsSimilar(clust,self.count)
                if belong:
                    similarclusters.append(i)
            if len(similarclusters)==0:
                self.clusters_sets.append([self.count])
            elif len(similarclusters)==1:
                self.clusters_sets[similarclusters[0]].append(self.count)
            else:
                new_clusters=[]
                merge_cluster=[]
                for i,clust in enumerate(self.clusters_sets):
                    if i in similarclusters:
                        merge_cluster.extend(clust)
                    else:
                        new_clusters.append(clust)
                new_clusters.append(merge_cluster)
                self.clusters_sets=new_clusters


    # check if timestamp_target has in its neighborhood one of timestamps_query
    def efficient_neighbor(self,timestamp_target,timestamps_query):
        # get the cluster of target:
        idtarget=self.index[timestamp_target]
        cluserid=-1
        for i in range(len(self.clusters_sets)):
            if idtarget in self.clusters_sets[i]:
                cluserid=i
                break
        if cluserid==-1:
            return False,0
        all_query=timestamps_query.copy()
        in_same_cluster=[]
        for id in self.clusters_sets[cluserid]:
            if self.contexts[id].timestamp in all_query:
                in_same_cluster.append(id)
                all_query.remove(self.contexts[id].timestamp)

        if len(in_same_cluster)==0:
            return False,0

        for id in in_same_cluster:
            dist=self.distance(id,idtarget)
            if dist&gt;self.cluster_similarity_limit:
                return True,dist
        return False,0
    def plot(self):
        num=1
        noisyclust=[]
        for clust in self.clusters_sets:
            if len(clust)&lt;=self.min_points:
                noisyclust.extend(clust)
                continue
            self.plotsingleclust(num,clust)
            num+=1

        self.plotsingleclust(num, noisyclust,&#34;noise&#34;)
        plt.show()


    def plotsingleclust(self,num,clust,desc=None):
        xaxistimes = [self.contexts[id].timestamp for id in clust]
        yaxistimes = [num for id in clust]
        if len(xaxistimes)==0:
            return
        edges = [self.contexts[id].CR[&#34;edges&#34;] for id in clust]
        if len(edges)!=0:
            edgeplot = edges[len(edges) // 2]
        else:
            edgeplot=[]
        toplot = &#34;&#34;
        seen = []
        for ed in edgeplot:
            if (ed[0], ed[1]) not in seen:
                toplot += f&#34;({ed[0]},{ed[1]}),&#34;
                seen.append((ed[1], ed[0]))
                seen.append((ed[0], ed[1]))
        if desc is None:
            plt.text(xaxistimes[len(xaxistimes) // 2], yaxistimes[len(yaxistimes) // 2] + 0.1, toplot, fontsize=8)
        else:
            plt.text(xaxistimes[len(xaxistimes) // 2], yaxistimes[len(yaxistimes) // 2] + 0.1, desc, fontsize=8)

        plt.scatter(xaxistimes, yaxistimes)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PdmContext.ContextClustering.DBscanContextStream.add_sample_to_cluster"><code class="name flex">
<span>def <span class="ident">add_sample_to_cluster</span></span>(<span>self, context: <a title="PdmContext.utils.structure.Context" href="utils/structure.html#PdmContext.utils.structure.Context">Context</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sample_to_cluster(self, context : Context):

    self.count+=1
    self.index[context.timestamp]=self.count
    self.contexts[self.count] = context
    #self.D.append([ self.context_ob.distance_cc(context,self.contexts[i])[0] for i in range(self.count)])
    #self.Co.append([ 1 if self.context_ob.distance_cc(context,self.contexts[i])[0]&gt;self.cluster_similarity_limit else 0 for i in range(self.count)])
    if len(self.clusters_sets)==0:
        self.clusters_sets.append([self.count])
    else:
        similarclusters=[]
        for i,clust in enumerate(self.clusters_sets):
            belong=self.clusterIsSimilar(clust,self.count)
            if belong:
                similarclusters.append(i)
        if len(similarclusters)==0:
            self.clusters_sets.append([self.count])
        elif len(similarclusters)==1:
            self.clusters_sets[similarclusters[0]].append(self.count)
        else:
            new_clusters=[]
            merge_cluster=[]
            for i,clust in enumerate(self.clusters_sets):
                if i in similarclusters:
                    merge_cluster.extend(clust)
                else:
                    new_clusters.append(clust)
            new_clusters.append(merge_cluster)
            self.clusters_sets=new_clusters</code></pre>
</details>
</dd>
<dt id="PdmContext.ContextClustering.DBscanContextStream.clusterIsSimilar"><code class="name flex">
<span>def <span class="ident">clusterIsSimilar</span></span>(<span>self, cluster, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clusterIsSimilar(self,cluster,id):
    for j in cluster:
        if self.distance(id, j) &gt; self.cluster_similarity_limit:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="PdmContext.ContextClustering.DBscanContextStream.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, id1, id2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self,id1,id2):
    return self.distanceTouse(self.contexts[id1],self.contexts[id2])</code></pre>
</details>
</dd>
<dt id="PdmContext.ContextClustering.DBscanContextStream.distance_default"><code class="name flex">
<span>def <span class="ident">distance_default</span></span>(<span>self, c1, c2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_default(self,c1,c2):
    return distances.distance_cc(c1, c2, self.a, self.b)[0]</code></pre>
</details>
</dd>
<dt id="PdmContext.ContextClustering.DBscanContextStream.efficient_neighbor"><code class="name flex">
<span>def <span class="ident">efficient_neighbor</span></span>(<span>self, timestamp_target, timestamps_query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficient_neighbor(self,timestamp_target,timestamps_query):
    # get the cluster of target:
    idtarget=self.index[timestamp_target]
    cluserid=-1
    for i in range(len(self.clusters_sets)):
        if idtarget in self.clusters_sets[i]:
            cluserid=i
            break
    if cluserid==-1:
        return False,0
    all_query=timestamps_query.copy()
    in_same_cluster=[]
    for id in self.clusters_sets[cluserid]:
        if self.contexts[id].timestamp in all_query:
            in_same_cluster.append(id)
            all_query.remove(self.contexts[id].timestamp)

    if len(in_same_cluster)==0:
        return False,0

    for id in in_same_cluster:
        dist=self.distance(id,idtarget)
        if dist&gt;self.cluster_similarity_limit:
            return True,dist
    return False,0</code></pre>
</details>
</dd>
<dt id="PdmContext.ContextClustering.DBscanContextStream.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):
    num=1
    noisyclust=[]
    for clust in self.clusters_sets:
        if len(clust)&lt;=self.min_points:
            noisyclust.extend(clust)
            continue
        self.plotsingleclust(num,clust)
        num+=1

    self.plotsingleclust(num, noisyclust,&#34;noise&#34;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="PdmContext.ContextClustering.DBscanContextStream.plotsingleclust"><code class="name flex">
<span>def <span class="ident">plotsingleclust</span></span>(<span>self, num, clust, desc=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotsingleclust(self,num,clust,desc=None):
    xaxistimes = [self.contexts[id].timestamp for id in clust]
    yaxistimes = [num for id in clust]
    if len(xaxistimes)==0:
        return
    edges = [self.contexts[id].CR[&#34;edges&#34;] for id in clust]
    if len(edges)!=0:
        edgeplot = edges[len(edges) // 2]
    else:
        edgeplot=[]
    toplot = &#34;&#34;
    seen = []
    for ed in edgeplot:
        if (ed[0], ed[1]) not in seen:
            toplot += f&#34;({ed[0]},{ed[1]}),&#34;
            seen.append((ed[1], ed[0]))
            seen.append((ed[0], ed[1]))
    if desc is None:
        plt.text(xaxistimes[len(xaxistimes) // 2], yaxistimes[len(yaxistimes) // 2] + 0.1, toplot, fontsize=8)
    else:
        plt.text(xaxistimes[len(xaxistimes) // 2], yaxistimes[len(yaxistimes) // 2] + 0.1, desc, fontsize=8)

    plt.scatter(xaxistimes, yaxistimes)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PdmContext" href="index.html">PdmContext</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PdmContext.ContextClustering.DBscanContextStream" href="#PdmContext.ContextClustering.DBscanContextStream">DBscanContextStream</a></code></h4>
<ul class="">
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.add_sample_to_cluster" href="#PdmContext.ContextClustering.DBscanContextStream.add_sample_to_cluster">add_sample_to_cluster</a></code></li>
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.clusterIsSimilar" href="#PdmContext.ContextClustering.DBscanContextStream.clusterIsSimilar">clusterIsSimilar</a></code></li>
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.distance" href="#PdmContext.ContextClustering.DBscanContextStream.distance">distance</a></code></li>
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.distance_default" href="#PdmContext.ContextClustering.DBscanContextStream.distance_default">distance_default</a></code></li>
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.efficient_neighbor" href="#PdmContext.ContextClustering.DBscanContextStream.efficient_neighbor">efficient_neighbor</a></code></li>
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.plot" href="#PdmContext.ContextClustering.DBscanContextStream.plot">plot</a></code></li>
<li><code><a title="PdmContext.ContextClustering.DBscanContextStream.plotsingleclust" href="#PdmContext.ContextClustering.DBscanContextStream.plotsingleclust">plotsingleclust</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>