<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PdmContext.utils.dbconnector API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PdmContext.utils.dbconnector</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pickle
import sqlite3
import time
from datetime import datetime
import codecs
import pandas
import pandas as pd
from PdmContext.utils.structure import Context
from influxdb import InfluxDBClient
from influxdb import DataFrameClient

from datetime import datetime
class SQLiteHandler:
    def __init__(self, db_name):
        &#34;&#34;&#34;

        **db_name**: the name of the database to load or create
        &#34;&#34;&#34;
        self.conn = sqlite3.connect(db_name,isolation_level = &#39;DEFERRED&#39;)
        self.cursor = self.conn.cursor()
        self.cursor.execute(&#39;&#39;&#39;PRAGMA synchronous = OFF&#39;&#39;&#39;)
        self.cursor.execute(&#39;&#39;&#39;PRAGMA journal_mode = OFF&#39;&#39;&#39;)

        self.create_table()
        #self.create_index(self, field_name)
    def create_table(self):
        &#34;&#34;&#34;
        Create a table with fields Date (datetime) and 3 text fields (target, contextpickle, metadata,value)
        target is the name of the target values,
        context pickle contain a Context object in binary form after pickle.dump()
        metadata, contain users metadate
        value, contain the last value of target series.

        &#34;&#34;&#34;
        self.cursor.execute(&#39;&#39;&#39;
            CREATE TABLE IF NOT EXISTS my_table (
                Date INTEGER,
                target TEXT,
                contextpickle TEXT,
                metadata TEXT,
                value REAL,
                PRIMARY KEY (Date, target)
            )
        &#39;&#39;&#39;)
        self.conn.commit()

    def create_index(self, field_name):
        # Create an index on a specified field (e.g., target)
        self.cursor.execute(f&#39;CREATE INDEX IF NOT EXISTS idx_{field_name} ON my_table({field_name})&#39;)
        self.conn.commit()

    def insert_record(self, date : pandas.Timestamp, target, context: Context,metadata=&#34;&#34;):
        &#34;&#34;&#34;
        Inserts a record of DATE,TARGET,Context (after pickle) , Meta data text, Value (which is the last target value from context)

        **Parameters**:

        **date**: The timestamp of the context

        **target**: The target name on which the context was built

        **context**: The Context object

        **metadata**: Text of possible meta data.
        &#34;&#34;&#34;

        unix_timestamp = int(time.mktime(date.timetuple()))
        tosave=self.create_pickle(context)
        self.cursor.execute(&#39;INSERT OR REPLACE INTO my_table (Date, target, contextpickle,metadata,value) VALUES (?, ?, ?, ?, ?)&#39;,
                            (unix_timestamp, str(target), tosave,metadata,context.CD[target][-1]))
        self.conn.commit()

    def get_records_between_dates(self, start_date, end_date,target):
        # Convert the start and end dates to Unix timestamps
        start_timestamp = int(time.mktime(start_date.timetuple()))
        end_timestamp = int(time.mktime(end_date.timetuple()))
        # Retrieve records between the specified dates
        self.cursor.execute(&#39;SELECT * FROM my_table WHERE Date &gt;= ? AND Date &lt;= ? AND target = ?&#39;, (start_timestamp, end_timestamp,target))
        records = self.cursor.fetchall()
        return records

    def get_contex_between_dates(self, start_date :pd.Timestamp, end_date:pd.Timestamp,target):
        &#34;&#34;&#34;
           Returns all Context object in list of the specified target between the start and end dates given.

           **Parameter**:

           **start_date**: Begin date of the query objects

           **end_date**: End date of the query objects

           **target**: the target of which the context will be returned

           **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;
        # Convert the start and end dates to Unix timestamps
        start_timestamp = int(time.mktime(start_date.timetuple()))
        end_timestamp = int(time.mktime(end_date.timetuple()))

        # Retrieve records between the specified dates
        self.cursor.execute(&#39;SELECT * FROM my_table WHERE Date &gt;= ? AND Date &lt;= ? AND target = ?&#39;, (start_timestamp, end_timestamp,target))
        records = self.cursor.fetchall()
        return_list=[]
        for record in records:
            date, target, context,metadata,value = record
            # If you stored the Date as Unix timestamp, convert it to a datetime object
            contextdict=self.load_pickle(context)
            return_list.append(contextdict)
        return return_list

    def get_all_context_by_target(self,target):
        &#34;&#34;&#34;
           Returns all Context object in list of the specified target.

           **Parameter**:

           **target**: the target of which the context will be returned

           **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;
        # Convert the start and end dates to Unix timestamps

        # Retrieve records between the specified dates
        self.cursor.execute(&#39;SELECT * FROM my_table WHERE target = ?&#39;, (target,))
        records = self.cursor.fetchall()
        return_list=[]
        for record in records:
            date, target, context,metadata,value  = record
            # If you stored the Date as Unix timestamp, convert it to a datetime object
            contextdict=self.load_pickle(context)
            return_list.append(contextdict)
        return return_list


    def load_pickle(self,data_string):

        # Convert the string back to bytes
        dcccoded=codecs.decode(data_string.encode(), &#34;base64&#34;)

        loaded_data = pickle.loads(dcccoded)

        return loaded_data

    def create_pickle(self,data):
        # Serialize the data to a bytes object
        data_bytes = codecs.encode(pickle.dumps(data), &#34;base64&#34;).decode()

        # Convert the bytes to a string
        data_string = str(data_bytes)

        return data_string

    def get_records_by_index(self, field_name, value):
        # Retrieve records based on the indexed field (e.g., target)
        self.cursor.execute(f&#39;SELECT * FROM my_table WHERE {field_name} = ?&#39;, (value,))
        records = self.cursor.fetchall()
        return records

    def get_records_by_fields(self,field_name1, field1_value,field_name2, field2_value):
        # Retrieve records based on the values of Field1 and Field2
        self.cursor.execute(f&#39;SELECT * FROM my_table WHERE {field_name1} = ? AND {field_name2} = ?&#39;, (field1_value, field2_value))
        records = self.cursor.fetchall()
        return records

    def close_connection(self):
        # Close the database connection
        self.conn.close()




class InfluxDBHandler:
    def __init__(self, host=&#39;localhost&#39;, port=8086, db_name=&#39;my_database&#39;,measurment_name=&#34;my_table&#34;):
        &#34;&#34;&#34;

        **host**: location of host (ip)

        **port**: port where the database is hosted

        **db_name**: Database name

        **measurment_name**:  measurment name to be used
        &#34;&#34;&#34;
        self.client = InfluxDBClient(host, port, db_name)
        self.client.create_database(db_name)
        self.db_name=db_name
        self.my_measurment=measurment_name
    def create_table(self):
        pass  # In InfluxDB, you don&#39;t need to explicitly create a table or measurement; it will be created on data insertion.
    def create_index(self,name):
        pass  # In InfluxDB, you don&#39;t need to explicitly create a table or measurement; it will be created on data insertion.

    def insert_record(self, date: pd.Timestamp, target, context: Context, meta_data=&#34;&#34;):
        &#34;&#34;&#34;
        Create a measurment with fields Date (datetime) and 3 text fields (target, contex (pickle), metadata,value)
        target is the name of the target values,
        context pickle contain a Context object in binary form after pickle.dump()
        metadata, contain users metadate
        value, contain the last value of target series.

        **Parameters**:

        **date**: Date of the context

        **target**: name of target series (for tag field)

        **context**: context object

        **meta_data**: meta data passed by user

        &#34;&#34;&#34;
        unix_timestamp = int(time.mktime(date.timetuple()))
        contextpickle = self.create_pickle(context)

        data = [
            {
                &#34;measurement&#34;: f&#34;{self.my_measurment}&#34;,
                &#34;tags&#34;: {
                    &#34;target&#34;: target,
                },
                &#34;time&#34;: unix_timestamp * 10**9,  # InfluxDB uses nanoseconds for timestamp
                &#34;fields&#34;: {
                    &#34;contextpickle&#34;: contextpickle,
                    &#34;metadata&#34;: meta_data,
                    &#34;value&#34;: context.CD[target][-1]
                }
            }
        ]

        self.client.write_points(data,database=self.db_name)


    def get_contex_between_dates(self, start_date: pd.Timestamp, end_date: pd.Timestamp, target):
        &#34;&#34;&#34;
           Returns all Context object in list of the specified target between the start and end dates given.

           **Parameter**:

           **start_date**: Begin date of the query objects

           **end_date**: End date of the query objects

           **target**: the target of which the context will be returned (tag)

           **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;

        query = f&#39;SELECT * FROM &#34;{self.my_measurment}&#34; WHERE (&#34;target&#34;::tag = \&#39;{target}\&#39;) AND time &gt;= {start_date.timestamp()} AND time &lt;= {end_date.timestamp()}&#39;
        result = self.client.query(query,database=self.db_name)
        return_list = []

        for record in result.get_points():
            contextdict = self.load_pickle(record[&#39;contextpickle&#39;])
            return_list.append(contextdict)

        return return_list

    def get_all_context_by_target(self,  target):
        &#34;&#34;&#34;
        Returns all Context object in list of the specified target.

        **Parameter**:

        **target**: the target of which the context will be returned (tag)

        **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;
        query = (f&#39;SELECT * FROM &#34;{self.my_measurment}&#34; WHERE (&#34;target&#34;::tag = \&#39;{target}\&#39;) &#39;)
        result = self.client.query(query,database=self.db_name)
        return_list = []

        for record in result.get_points():
            contextdict = self.load_pickle(record[f&#39;contextpickle&#39;])
            return_list.append(contextdict)

        return return_list


    def load_pickle(self, data_string):
        # Convert the string back to bytes
        data_string = data_string.split(&#34;\\n&#34;)[:-1]
        original=&#34;&#34;
        for sstring in data_string:
            original+=f&#34;{sstring}\n&#34;
        encoded = original.encode()
        dcccoded = codecs.decode(encoded, &#34;base64&#34;)

        loaded_data = pickle.loads(dcccoded)

        return loaded_data

    def create_pickle(self, data):
        # Serialize the data to a bytes object
        data_bytes = codecs.encode(pickle.dumps(data), &#34;base64&#34;).decode()

        # Convert the bytes to a string
        data_string = str(data_bytes)

        return data_string

    def close_connection(self):
        pass  # InfluxDB connection is closed automatically when the client is closed</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler"><code class="flex name class">
<span>class <span class="ident">InfluxDBHandler</span></span>
<span>(</span><span>host='localhost', port=8086, db_name='my_database', measurment_name='my_table')</span>
</code></dt>
<dd>
<div class="desc"><p><strong>host</strong>: location of host (ip)</p>
<p><strong>port</strong>: port where the database is hosted</p>
<p><strong>db_name</strong>: Database name</p>
<p><strong>measurment_name</strong>:
measurment name to be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InfluxDBHandler:
    def __init__(self, host=&#39;localhost&#39;, port=8086, db_name=&#39;my_database&#39;,measurment_name=&#34;my_table&#34;):
        &#34;&#34;&#34;

        **host**: location of host (ip)

        **port**: port where the database is hosted

        **db_name**: Database name

        **measurment_name**:  measurment name to be used
        &#34;&#34;&#34;
        self.client = InfluxDBClient(host, port, db_name)
        self.client.create_database(db_name)
        self.db_name=db_name
        self.my_measurment=measurment_name
    def create_table(self):
        pass  # In InfluxDB, you don&#39;t need to explicitly create a table or measurement; it will be created on data insertion.
    def create_index(self,name):
        pass  # In InfluxDB, you don&#39;t need to explicitly create a table or measurement; it will be created on data insertion.

    def insert_record(self, date: pd.Timestamp, target, context: Context, meta_data=&#34;&#34;):
        &#34;&#34;&#34;
        Create a measurment with fields Date (datetime) and 3 text fields (target, contex (pickle), metadata,value)
        target is the name of the target values,
        context pickle contain a Context object in binary form after pickle.dump()
        metadata, contain users metadate
        value, contain the last value of target series.

        **Parameters**:

        **date**: Date of the context

        **target**: name of target series (for tag field)

        **context**: context object

        **meta_data**: meta data passed by user

        &#34;&#34;&#34;
        unix_timestamp = int(time.mktime(date.timetuple()))
        contextpickle = self.create_pickle(context)

        data = [
            {
                &#34;measurement&#34;: f&#34;{self.my_measurment}&#34;,
                &#34;tags&#34;: {
                    &#34;target&#34;: target,
                },
                &#34;time&#34;: unix_timestamp * 10**9,  # InfluxDB uses nanoseconds for timestamp
                &#34;fields&#34;: {
                    &#34;contextpickle&#34;: contextpickle,
                    &#34;metadata&#34;: meta_data,
                    &#34;value&#34;: context.CD[target][-1]
                }
            }
        ]

        self.client.write_points(data,database=self.db_name)


    def get_contex_between_dates(self, start_date: pd.Timestamp, end_date: pd.Timestamp, target):
        &#34;&#34;&#34;
           Returns all Context object in list of the specified target between the start and end dates given.

           **Parameter**:

           **start_date**: Begin date of the query objects

           **end_date**: End date of the query objects

           **target**: the target of which the context will be returned (tag)

           **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;

        query = f&#39;SELECT * FROM &#34;{self.my_measurment}&#34; WHERE (&#34;target&#34;::tag = \&#39;{target}\&#39;) AND time &gt;= {start_date.timestamp()} AND time &lt;= {end_date.timestamp()}&#39;
        result = self.client.query(query,database=self.db_name)
        return_list = []

        for record in result.get_points():
            contextdict = self.load_pickle(record[&#39;contextpickle&#39;])
            return_list.append(contextdict)

        return return_list

    def get_all_context_by_target(self,  target):
        &#34;&#34;&#34;
        Returns all Context object in list of the specified target.

        **Parameter**:

        **target**: the target of which the context will be returned (tag)

        **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;
        query = (f&#39;SELECT * FROM &#34;{self.my_measurment}&#34; WHERE (&#34;target&#34;::tag = \&#39;{target}\&#39;) &#39;)
        result = self.client.query(query,database=self.db_name)
        return_list = []

        for record in result.get_points():
            contextdict = self.load_pickle(record[f&#39;contextpickle&#39;])
            return_list.append(contextdict)

        return return_list


    def load_pickle(self, data_string):
        # Convert the string back to bytes
        data_string = data_string.split(&#34;\\n&#34;)[:-1]
        original=&#34;&#34;
        for sstring in data_string:
            original+=f&#34;{sstring}\n&#34;
        encoded = original.encode()
        dcccoded = codecs.decode(encoded, &#34;base64&#34;)

        loaded_data = pickle.loads(dcccoded)

        return loaded_data

    def create_pickle(self, data):
        # Serialize the data to a bytes object
        data_bytes = codecs.encode(pickle.dumps(data), &#34;base64&#34;).decode()

        # Convert the bytes to a string
        data_string = str(data_bytes)

        return data_string

    def close_connection(self):
        pass  # InfluxDB connection is closed automatically when the client is closed</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.close_connection"><code class="name flex">
<span>def <span class="ident">close_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_connection(self):
    pass  # InfluxDB connection is closed automatically when the client is closed</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.create_index"><code class="name flex">
<span>def <span class="ident">create_index</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_index(self,name):
    pass  # In InfluxDB, you don&#39;t need to explicitly create a table or measurement; it will be created on data insertion.</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.create_pickle"><code class="name flex">
<span>def <span class="ident">create_pickle</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_pickle(self, data):
    # Serialize the data to a bytes object
    data_bytes = codecs.encode(pickle.dumps(data), &#34;base64&#34;).decode()

    # Convert the bytes to a string
    data_string = str(data_bytes)

    return data_string</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.create_table"><code class="name flex">
<span>def <span class="ident">create_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_table(self):
    pass  # In InfluxDB, you don&#39;t need to explicitly create a table or measurement; it will be created on data insertion.</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.get_all_context_by_target"><code class="name flex">
<span>def <span class="ident">get_all_context_by_target</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all Context object in list of the specified target.</p>
<p><strong>Parameter</strong>:</p>
<p><strong>target</strong>: the target of which the context will be returned (tag)</p>
<p><strong>return</strong>: A list of from PdmContext.utils.structure.Context objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_context_by_target(self,  target):
    &#34;&#34;&#34;
    Returns all Context object in list of the specified target.

    **Parameter**:

    **target**: the target of which the context will be returned (tag)

    **return**: A list of from PdmContext.utils.structure.Context objects
    &#34;&#34;&#34;
    query = (f&#39;SELECT * FROM &#34;{self.my_measurment}&#34; WHERE (&#34;target&#34;::tag = \&#39;{target}\&#39;) &#39;)
    result = self.client.query(query,database=self.db_name)
    return_list = []

    for record in result.get_points():
        contextdict = self.load_pickle(record[f&#39;contextpickle&#39;])
        return_list.append(contextdict)

    return return_list</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.get_contex_between_dates"><code class="name flex">
<span>def <span class="ident">get_contex_between_dates</span></span>(<span>self, start_date: pandas._libs.tslibs.timestamps.Timestamp, end_date: pandas._libs.tslibs.timestamps.Timestamp, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all Context object in list of the specified target between the start and end dates given.</p>
<p><strong>Parameter</strong>:</p>
<p><strong>start_date</strong>: Begin date of the query objects</p>
<p><strong>end_date</strong>: End date of the query objects</p>
<p><strong>target</strong>: the target of which the context will be returned (tag)</p>
<p><strong>return</strong>: A list of from PdmContext.utils.structure.Context objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contex_between_dates(self, start_date: pd.Timestamp, end_date: pd.Timestamp, target):
    &#34;&#34;&#34;
       Returns all Context object in list of the specified target between the start and end dates given.

       **Parameter**:

       **start_date**: Begin date of the query objects

       **end_date**: End date of the query objects

       **target**: the target of which the context will be returned (tag)

       **return**: A list of from PdmContext.utils.structure.Context objects
    &#34;&#34;&#34;

    query = f&#39;SELECT * FROM &#34;{self.my_measurment}&#34; WHERE (&#34;target&#34;::tag = \&#39;{target}\&#39;) AND time &gt;= {start_date.timestamp()} AND time &lt;= {end_date.timestamp()}&#39;
    result = self.client.query(query,database=self.db_name)
    return_list = []

    for record in result.get_points():
        contextdict = self.load_pickle(record[&#39;contextpickle&#39;])
        return_list.append(contextdict)

    return return_list</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.insert_record"><code class="name flex">
<span>def <span class="ident">insert_record</span></span>(<span>self, date: pandas._libs.tslibs.timestamps.Timestamp, target, context: <a title="PdmContext.utils.structure.Context" href="structure.html#PdmContext.utils.structure.Context">Context</a>, meta_data='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a measurment with fields Date (datetime) and 3 text fields (target, contex (pickle), metadata,value)
target is the name of the target values,
context pickle contain a Context object in binary form after pickle.dump()
metadata, contain users metadate
value, contain the last value of target series.</p>
<p><strong>Parameters</strong>:</p>
<p><strong>date</strong>: Date of the context</p>
<p><strong>target</strong>: name of target series (for tag field)</p>
<p><strong>context</strong>: context object</p>
<p><strong>meta_data</strong>: meta data passed by user</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_record(self, date: pd.Timestamp, target, context: Context, meta_data=&#34;&#34;):
    &#34;&#34;&#34;
    Create a measurment with fields Date (datetime) and 3 text fields (target, contex (pickle), metadata,value)
    target is the name of the target values,
    context pickle contain a Context object in binary form after pickle.dump()
    metadata, contain users metadate
    value, contain the last value of target series.

    **Parameters**:

    **date**: Date of the context

    **target**: name of target series (for tag field)

    **context**: context object

    **meta_data**: meta data passed by user

    &#34;&#34;&#34;
    unix_timestamp = int(time.mktime(date.timetuple()))
    contextpickle = self.create_pickle(context)

    data = [
        {
            &#34;measurement&#34;: f&#34;{self.my_measurment}&#34;,
            &#34;tags&#34;: {
                &#34;target&#34;: target,
            },
            &#34;time&#34;: unix_timestamp * 10**9,  # InfluxDB uses nanoseconds for timestamp
            &#34;fields&#34;: {
                &#34;contextpickle&#34;: contextpickle,
                &#34;metadata&#34;: meta_data,
                &#34;value&#34;: context.CD[target][-1]
            }
        }
    ]

    self.client.write_points(data,database=self.db_name)</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.InfluxDBHandler.load_pickle"><code class="name flex">
<span>def <span class="ident">load_pickle</span></span>(<span>self, data_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pickle(self, data_string):
    # Convert the string back to bytes
    data_string = data_string.split(&#34;\\n&#34;)[:-1]
    original=&#34;&#34;
    for sstring in data_string:
        original+=f&#34;{sstring}\n&#34;
    encoded = original.encode()
    dcccoded = codecs.decode(encoded, &#34;base64&#34;)

    loaded_data = pickle.loads(dcccoded)

    return loaded_data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler"><code class="flex name class">
<span>class <span class="ident">SQLiteHandler</span></span>
<span>(</span><span>db_name)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>db_name</strong>: the name of the database to load or create</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQLiteHandler:
    def __init__(self, db_name):
        &#34;&#34;&#34;

        **db_name**: the name of the database to load or create
        &#34;&#34;&#34;
        self.conn = sqlite3.connect(db_name,isolation_level = &#39;DEFERRED&#39;)
        self.cursor = self.conn.cursor()
        self.cursor.execute(&#39;&#39;&#39;PRAGMA synchronous = OFF&#39;&#39;&#39;)
        self.cursor.execute(&#39;&#39;&#39;PRAGMA journal_mode = OFF&#39;&#39;&#39;)

        self.create_table()
        #self.create_index(self, field_name)
    def create_table(self):
        &#34;&#34;&#34;
        Create a table with fields Date (datetime) and 3 text fields (target, contextpickle, metadata,value)
        target is the name of the target values,
        context pickle contain a Context object in binary form after pickle.dump()
        metadata, contain users metadate
        value, contain the last value of target series.

        &#34;&#34;&#34;
        self.cursor.execute(&#39;&#39;&#39;
            CREATE TABLE IF NOT EXISTS my_table (
                Date INTEGER,
                target TEXT,
                contextpickle TEXT,
                metadata TEXT,
                value REAL,
                PRIMARY KEY (Date, target)
            )
        &#39;&#39;&#39;)
        self.conn.commit()

    def create_index(self, field_name):
        # Create an index on a specified field (e.g., target)
        self.cursor.execute(f&#39;CREATE INDEX IF NOT EXISTS idx_{field_name} ON my_table({field_name})&#39;)
        self.conn.commit()

    def insert_record(self, date : pandas.Timestamp, target, context: Context,metadata=&#34;&#34;):
        &#34;&#34;&#34;
        Inserts a record of DATE,TARGET,Context (after pickle) , Meta data text, Value (which is the last target value from context)

        **Parameters**:

        **date**: The timestamp of the context

        **target**: The target name on which the context was built

        **context**: The Context object

        **metadata**: Text of possible meta data.
        &#34;&#34;&#34;

        unix_timestamp = int(time.mktime(date.timetuple()))
        tosave=self.create_pickle(context)
        self.cursor.execute(&#39;INSERT OR REPLACE INTO my_table (Date, target, contextpickle,metadata,value) VALUES (?, ?, ?, ?, ?)&#39;,
                            (unix_timestamp, str(target), tosave,metadata,context.CD[target][-1]))
        self.conn.commit()

    def get_records_between_dates(self, start_date, end_date,target):
        # Convert the start and end dates to Unix timestamps
        start_timestamp = int(time.mktime(start_date.timetuple()))
        end_timestamp = int(time.mktime(end_date.timetuple()))
        # Retrieve records between the specified dates
        self.cursor.execute(&#39;SELECT * FROM my_table WHERE Date &gt;= ? AND Date &lt;= ? AND target = ?&#39;, (start_timestamp, end_timestamp,target))
        records = self.cursor.fetchall()
        return records

    def get_contex_between_dates(self, start_date :pd.Timestamp, end_date:pd.Timestamp,target):
        &#34;&#34;&#34;
           Returns all Context object in list of the specified target between the start and end dates given.

           **Parameter**:

           **start_date**: Begin date of the query objects

           **end_date**: End date of the query objects

           **target**: the target of which the context will be returned

           **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;
        # Convert the start and end dates to Unix timestamps
        start_timestamp = int(time.mktime(start_date.timetuple()))
        end_timestamp = int(time.mktime(end_date.timetuple()))

        # Retrieve records between the specified dates
        self.cursor.execute(&#39;SELECT * FROM my_table WHERE Date &gt;= ? AND Date &lt;= ? AND target = ?&#39;, (start_timestamp, end_timestamp,target))
        records = self.cursor.fetchall()
        return_list=[]
        for record in records:
            date, target, context,metadata,value = record
            # If you stored the Date as Unix timestamp, convert it to a datetime object
            contextdict=self.load_pickle(context)
            return_list.append(contextdict)
        return return_list

    def get_all_context_by_target(self,target):
        &#34;&#34;&#34;
           Returns all Context object in list of the specified target.

           **Parameter**:

           **target**: the target of which the context will be returned

           **return**: A list of from PdmContext.utils.structure.Context objects
        &#34;&#34;&#34;
        # Convert the start and end dates to Unix timestamps

        # Retrieve records between the specified dates
        self.cursor.execute(&#39;SELECT * FROM my_table WHERE target = ?&#39;, (target,))
        records = self.cursor.fetchall()
        return_list=[]
        for record in records:
            date, target, context,metadata,value  = record
            # If you stored the Date as Unix timestamp, convert it to a datetime object
            contextdict=self.load_pickle(context)
            return_list.append(contextdict)
        return return_list


    def load_pickle(self,data_string):

        # Convert the string back to bytes
        dcccoded=codecs.decode(data_string.encode(), &#34;base64&#34;)

        loaded_data = pickle.loads(dcccoded)

        return loaded_data

    def create_pickle(self,data):
        # Serialize the data to a bytes object
        data_bytes = codecs.encode(pickle.dumps(data), &#34;base64&#34;).decode()

        # Convert the bytes to a string
        data_string = str(data_bytes)

        return data_string

    def get_records_by_index(self, field_name, value):
        # Retrieve records based on the indexed field (e.g., target)
        self.cursor.execute(f&#39;SELECT * FROM my_table WHERE {field_name} = ?&#39;, (value,))
        records = self.cursor.fetchall()
        return records

    def get_records_by_fields(self,field_name1, field1_value,field_name2, field2_value):
        # Retrieve records based on the values of Field1 and Field2
        self.cursor.execute(f&#39;SELECT * FROM my_table WHERE {field_name1} = ? AND {field_name2} = ?&#39;, (field1_value, field2_value))
        records = self.cursor.fetchall()
        return records

    def close_connection(self):
        # Close the database connection
        self.conn.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.close_connection"><code class="name flex">
<span>def <span class="ident">close_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_connection(self):
    # Close the database connection
    self.conn.close()</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.create_index"><code class="name flex">
<span>def <span class="ident">create_index</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_index(self, field_name):
    # Create an index on a specified field (e.g., target)
    self.cursor.execute(f&#39;CREATE INDEX IF NOT EXISTS idx_{field_name} ON my_table({field_name})&#39;)
    self.conn.commit()</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.create_pickle"><code class="name flex">
<span>def <span class="ident">create_pickle</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_pickle(self,data):
    # Serialize the data to a bytes object
    data_bytes = codecs.encode(pickle.dumps(data), &#34;base64&#34;).decode()

    # Convert the bytes to a string
    data_string = str(data_bytes)

    return data_string</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.create_table"><code class="name flex">
<span>def <span class="ident">create_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a table with fields Date (datetime) and 3 text fields (target, contextpickle, metadata,value)
target is the name of the target values,
context pickle contain a Context object in binary form after pickle.dump()
metadata, contain users metadate
value, contain the last value of target series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_table(self):
    &#34;&#34;&#34;
    Create a table with fields Date (datetime) and 3 text fields (target, contextpickle, metadata,value)
    target is the name of the target values,
    context pickle contain a Context object in binary form after pickle.dump()
    metadata, contain users metadate
    value, contain the last value of target series.

    &#34;&#34;&#34;
    self.cursor.execute(&#39;&#39;&#39;
        CREATE TABLE IF NOT EXISTS my_table (
            Date INTEGER,
            target TEXT,
            contextpickle TEXT,
            metadata TEXT,
            value REAL,
            PRIMARY KEY (Date, target)
        )
    &#39;&#39;&#39;)
    self.conn.commit()</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.get_all_context_by_target"><code class="name flex">
<span>def <span class="ident">get_all_context_by_target</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all Context object in list of the specified target.</p>
<p><strong>Parameter</strong>:</p>
<p><strong>target</strong>: the target of which the context will be returned</p>
<p><strong>return</strong>: A list of from PdmContext.utils.structure.Context objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_context_by_target(self,target):
    &#34;&#34;&#34;
       Returns all Context object in list of the specified target.

       **Parameter**:

       **target**: the target of which the context will be returned

       **return**: A list of from PdmContext.utils.structure.Context objects
    &#34;&#34;&#34;
    # Convert the start and end dates to Unix timestamps

    # Retrieve records between the specified dates
    self.cursor.execute(&#39;SELECT * FROM my_table WHERE target = ?&#39;, (target,))
    records = self.cursor.fetchall()
    return_list=[]
    for record in records:
        date, target, context,metadata,value  = record
        # If you stored the Date as Unix timestamp, convert it to a datetime object
        contextdict=self.load_pickle(context)
        return_list.append(contextdict)
    return return_list</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.get_contex_between_dates"><code class="name flex">
<span>def <span class="ident">get_contex_between_dates</span></span>(<span>self, start_date: pandas._libs.tslibs.timestamps.Timestamp, end_date: pandas._libs.tslibs.timestamps.Timestamp, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all Context object in list of the specified target between the start and end dates given.</p>
<p><strong>Parameter</strong>:</p>
<p><strong>start_date</strong>: Begin date of the query objects</p>
<p><strong>end_date</strong>: End date of the query objects</p>
<p><strong>target</strong>: the target of which the context will be returned</p>
<p><strong>return</strong>: A list of from PdmContext.utils.structure.Context objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contex_between_dates(self, start_date :pd.Timestamp, end_date:pd.Timestamp,target):
    &#34;&#34;&#34;
       Returns all Context object in list of the specified target between the start and end dates given.

       **Parameter**:

       **start_date**: Begin date of the query objects

       **end_date**: End date of the query objects

       **target**: the target of which the context will be returned

       **return**: A list of from PdmContext.utils.structure.Context objects
    &#34;&#34;&#34;
    # Convert the start and end dates to Unix timestamps
    start_timestamp = int(time.mktime(start_date.timetuple()))
    end_timestamp = int(time.mktime(end_date.timetuple()))

    # Retrieve records between the specified dates
    self.cursor.execute(&#39;SELECT * FROM my_table WHERE Date &gt;= ? AND Date &lt;= ? AND target = ?&#39;, (start_timestamp, end_timestamp,target))
    records = self.cursor.fetchall()
    return_list=[]
    for record in records:
        date, target, context,metadata,value = record
        # If you stored the Date as Unix timestamp, convert it to a datetime object
        contextdict=self.load_pickle(context)
        return_list.append(contextdict)
    return return_list</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.get_records_between_dates"><code class="name flex">
<span>def <span class="ident">get_records_between_dates</span></span>(<span>self, start_date, end_date, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_records_between_dates(self, start_date, end_date,target):
    # Convert the start and end dates to Unix timestamps
    start_timestamp = int(time.mktime(start_date.timetuple()))
    end_timestamp = int(time.mktime(end_date.timetuple()))
    # Retrieve records between the specified dates
    self.cursor.execute(&#39;SELECT * FROM my_table WHERE Date &gt;= ? AND Date &lt;= ? AND target = ?&#39;, (start_timestamp, end_timestamp,target))
    records = self.cursor.fetchall()
    return records</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.get_records_by_fields"><code class="name flex">
<span>def <span class="ident">get_records_by_fields</span></span>(<span>self, field_name1, field1_value, field_name2, field2_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_records_by_fields(self,field_name1, field1_value,field_name2, field2_value):
    # Retrieve records based on the values of Field1 and Field2
    self.cursor.execute(f&#39;SELECT * FROM my_table WHERE {field_name1} = ? AND {field_name2} = ?&#39;, (field1_value, field2_value))
    records = self.cursor.fetchall()
    return records</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.get_records_by_index"><code class="name flex">
<span>def <span class="ident">get_records_by_index</span></span>(<span>self, field_name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_records_by_index(self, field_name, value):
    # Retrieve records based on the indexed field (e.g., target)
    self.cursor.execute(f&#39;SELECT * FROM my_table WHERE {field_name} = ?&#39;, (value,))
    records = self.cursor.fetchall()
    return records</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.insert_record"><code class="name flex">
<span>def <span class="ident">insert_record</span></span>(<span>self, date: pandas._libs.tslibs.timestamps.Timestamp, target, context: <a title="PdmContext.utils.structure.Context" href="structure.html#PdmContext.utils.structure.Context">Context</a>, metadata='')</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts a record of DATE,TARGET,Context (after pickle) , Meta data text, Value (which is the last target value from context)</p>
<p><strong>Parameters</strong>:</p>
<p><strong>date</strong>: The timestamp of the context</p>
<p><strong>target</strong>: The target name on which the context was built</p>
<p><strong>context</strong>: The Context object</p>
<p><strong>metadata</strong>: Text of possible meta data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_record(self, date : pandas.Timestamp, target, context: Context,metadata=&#34;&#34;):
    &#34;&#34;&#34;
    Inserts a record of DATE,TARGET,Context (after pickle) , Meta data text, Value (which is the last target value from context)

    **Parameters**:

    **date**: The timestamp of the context

    **target**: The target name on which the context was built

    **context**: The Context object

    **metadata**: Text of possible meta data.
    &#34;&#34;&#34;

    unix_timestamp = int(time.mktime(date.timetuple()))
    tosave=self.create_pickle(context)
    self.cursor.execute(&#39;INSERT OR REPLACE INTO my_table (Date, target, contextpickle,metadata,value) VALUES (?, ?, ?, ?, ?)&#39;,
                        (unix_timestamp, str(target), tosave,metadata,context.CD[target][-1]))
    self.conn.commit()</code></pre>
</details>
</dd>
<dt id="PdmContext.utils.dbconnector.SQLiteHandler.load_pickle"><code class="name flex">
<span>def <span class="ident">load_pickle</span></span>(<span>self, data_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pickle(self,data_string):

    # Convert the string back to bytes
    dcccoded=codecs.decode(data_string.encode(), &#34;base64&#34;)

    loaded_data = pickle.loads(dcccoded)

    return loaded_data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PdmContext.utils" href="index.html">PdmContext.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler" href="#PdmContext.utils.dbconnector.InfluxDBHandler">InfluxDBHandler</a></code></h4>
<ul class="">
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.close_connection" href="#PdmContext.utils.dbconnector.InfluxDBHandler.close_connection">close_connection</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.create_index" href="#PdmContext.utils.dbconnector.InfluxDBHandler.create_index">create_index</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.create_pickle" href="#PdmContext.utils.dbconnector.InfluxDBHandler.create_pickle">create_pickle</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.create_table" href="#PdmContext.utils.dbconnector.InfluxDBHandler.create_table">create_table</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.get_all_context_by_target" href="#PdmContext.utils.dbconnector.InfluxDBHandler.get_all_context_by_target">get_all_context_by_target</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.get_contex_between_dates" href="#PdmContext.utils.dbconnector.InfluxDBHandler.get_contex_between_dates">get_contex_between_dates</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.insert_record" href="#PdmContext.utils.dbconnector.InfluxDBHandler.insert_record">insert_record</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.InfluxDBHandler.load_pickle" href="#PdmContext.utils.dbconnector.InfluxDBHandler.load_pickle">load_pickle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="PdmContext.utils.dbconnector.SQLiteHandler" href="#PdmContext.utils.dbconnector.SQLiteHandler">SQLiteHandler</a></code></h4>
<ul class="">
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.close_connection" href="#PdmContext.utils.dbconnector.SQLiteHandler.close_connection">close_connection</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.create_index" href="#PdmContext.utils.dbconnector.SQLiteHandler.create_index">create_index</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.create_pickle" href="#PdmContext.utils.dbconnector.SQLiteHandler.create_pickle">create_pickle</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.create_table" href="#PdmContext.utils.dbconnector.SQLiteHandler.create_table">create_table</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.get_all_context_by_target" href="#PdmContext.utils.dbconnector.SQLiteHandler.get_all_context_by_target">get_all_context_by_target</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.get_contex_between_dates" href="#PdmContext.utils.dbconnector.SQLiteHandler.get_contex_between_dates">get_contex_between_dates</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.get_records_between_dates" href="#PdmContext.utils.dbconnector.SQLiteHandler.get_records_between_dates">get_records_between_dates</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.get_records_by_fields" href="#PdmContext.utils.dbconnector.SQLiteHandler.get_records_by_fields">get_records_by_fields</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.get_records_by_index" href="#PdmContext.utils.dbconnector.SQLiteHandler.get_records_by_index">get_records_by_index</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.insert_record" href="#PdmContext.utils.dbconnector.SQLiteHandler.insert_record">insert_record</a></code></li>
<li><code><a title="PdmContext.utils.dbconnector.SQLiteHandler.load_pickle" href="#PdmContext.utils.dbconnector.SQLiteHandler.load_pickle">load_pickle</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>